[参考](https://blog.csdn.net/laoyang360/article/details/79253294)
## 1、聚合为什么慢？
大多数时候对单个字段的聚合查询还是非常快的， 但是当需要同时聚合多个字段时，就可能会产生大量的分组，最终结果就是占用 es 大量内存，从而导致 OOM 的情况发生。 
实践应用发现，以下情况都会比较慢： 
1. 待聚合文档数比较多（千万、亿、十亿甚至更多）； 
2. 聚合条件比较复杂（多重条件聚合）； 
3. 全量聚合（翻页的场景用）。


## 2、聚合优化方案探讨
优化方案一：默认深度优先聚合改为广度优先聚合。
```
"collect_mode" : "breadth_first"
```
* depth_first 直接进行子聚合的计算
* breadth_first 先计算出当前聚合的结果，针对这个结果在对子聚合进行计算。

优化方案二： 每一层terms aggregation内部加一个 “execution_hint”: “map”。
```
"execution_hint": "map"
```
> terms aggregation  默认的计算方式并非直观感觉上的先查询，然后基于查询结果聚合。

> ES 假定用户需要聚合的数据集是海量的，如果将查询结果放在内存中计算，内存消耗非常大。
因此 ES 利用了一种叫做 global ordinals 的数据结构来对聚合的字段来做 bucket 分配，这个 ordinals 用有序的数值来代表字段里唯一的一个字符串，因此为每一个 ordinals 值分配一个 bucket，就等同于为每一个唯一的 term 分配了 bucket 。之后遍历查询结果的时候，可以将结果映射到 各个 bucket 里，就可以很快地统计出 每个 bucket 里的文档数。

> 这种计算方式主要开销在构建 global ordinals 和分配 bucket 上，如果索引包含的原始文档非常多，查询结果包含的文档也很多，那么默认的这种计算方式是消耗内存最小,速度最快的。

> 如果指定 execution_hit:map 则会更改聚合的方式，这种方式不需要构建 global ordinals，而是直接将查询结果拿到内存里构造一个 map 来计算， 因此在查询结果集很小的情况下会显著的比 global ordinals 快

> 要注意 平衡点问题。 map 的内存开销带来的代价可能抵消了构造 global ordinals 的开销，从而比 global ordinals 慢，所以需要测试找到平衡点。

### Map方式的结论可简要概括如下： 
1. 查询结果直接放入内存中构建map，在查询结果集小的场景下，速度极快； 
2. 但如果待结果集合很大的情况，map方式不一定也快。